# ---------------
# standard setup and imports
# ---------------

from typing import Dict, Any, List, Optional
from pydantic import BaseModel, Field, create_model
from openai import OpenAI
import instructor
import json

# Apply the patch to the OpenAI client
# enables response_model keyword
client = instructor.from_openai(OpenAI())

# -------------o--
# pydantic models
# ---------------


class Question(BaseModel):
    number: int = Field(..., description="question number")
    question: str
    support: Optional[List[str]] = Field(
        default=None,
        description="what part of given question text supports this question",
    )
    dependencies: Optional[List[int]] = Field(
        default=None, description="whether this question depends on any other question"
    )


class QuestionWithPythonCode(BaseModel):
    question: Question
    python_program: str


# ---------------
# step 1: decompose the question in natural language (NL) + symbolic language (SL)
# ---------------


# Function to decompose the user query into sub-questions
async def decompose_query(query: str) -> List:
    decomposition_prompt = f"""
        Q: {query}
        # To solve this question, we answer each of the following subquestions with a Python program:
        """
    print(f"\nDecomposition Prompt:\n{decomposition_prompt}\n")

    sub_questions_response = client.chat.completions.create(
        messages=[{"role": "user", "content": decomposition_prompt}],
        model="gpt-4o",
        response_model=List[QuestionWithPythonCode],
    )

    # Convert Pydantic models to JSON
    json_data = [question.model_dump() for question in sub_questions_response]

    print(f"Sub-Questions Response:\n\n")
    for question in sub_questions_response:
        print(print_format_question(question))
    # print(json.dumps(json_data, indent=4))
    return json_data


# ---------------
# step 2: deterministcally solve the code returned by LLM
# ---------------


# Main function to handle the user query
async def handle_user_query(query: str) -> QuestionWithPythonCode:
    # Step 1: Decompose the query into sub-questions
    print(f"\nHandling User Query:\n{query}\n")
    sub_questions_json = await decompose_query(query)

    # Step 2: Deterministically solve the question
    python_programs = [q["python_program"] for q in sub_questions_json]

    for code_string in python_programs:
        result = solve_it(code_string)
        print(f"Result for code: \t {code_string}\n{result}\n\n")

    return result


def print_format_question(data: QuestionWithPythonCode) -> str:

    question_data = data.question

    first_line = f"Question_number: {question_data.number} {question_data.question} (support: {question_data.support}, dependencies: {question_data.dependencies})"
    second_line = f"python_program: \n {data.python_program }"

    return f"{first_line} \n {second_line}\n"


# ---------------
# solves the python program generated by the model
# ---------------


def solve_it(code_string):
    """
    Solves the cookie code given as a string.

    Args:
        code_string: The string containing the Python code to execute.

    Returns:
        The result of the code execution.

    # Example usage
    code_strings = [
        "oatmeal_cookies_initial = 9\n# After eating 1 oatmeal cookie for snack and 2 more for lunch\noatmeal_cookies_remaining = oatmeal_cookies_initial - 1 - 2\noatmeal_cookies_remaining",
        "chocolate_chip_cookies_initial = 4\n# After eating 1 chocolate chip cookie for snack\nchocolate_chip_cookies_remaining = chocolate_chip_cookies_initial - 1\nchocolate_chip_cookies_remaining",
        "sugar_cookies_initial = 5\n# After eating 1 sugar cookie for snack and giving 2 more to friends\nsugar_cookies_remaining = sugar_cookies_initial - 1 - 2\nsugar_cookies_remaining",
        "# Results from previous questions\noatmeal_cookies_remaining = 6\nchocolate_chip_cookies_remaining = 3\nsugar_cookies_remaining = 2\n# Total cookies left after eating and giving away \ntotal_cookies_remaining = oatmeal_cookies_remaining + chocolate_chip_cookies_remaining + sugar_cookies_remaining\ntotal_cookies_remaining",
        "# Results from previous question\ntotal_cookies_remaining = 11\n# Randy bakes 4 of each flavor (oatmeal, chocolate chip, sugar)\ncookies_baked = 4 * 3 # 3 types of cookies\ntotal_cookies_after_baking = total_cookies_remaining + cookies_baked\ntotal_cookies_after_baking"
    ]

    for code_string in code_strings:
        result = solve_it(code_string)
        print(f"Result for code: {code_string}\n{result}\n")
    """

    # Split the code into lines
    lines = code_string.splitlines()

    # Create a dictionary to store variables
    variables = {}

    # Execute each line of code
    for line in lines:
        if line.startswith("#"):  # Skip comment lines
            continue
        else:
            try:
                # Execute the line as Python code
                exec(line, variables)
            except Exception as e:
                print(f"Error executing line: {line}\nError: {e}")

    # Return the value of the last variable declared
    return variables[line.split("=")[0].strip()]


# Example usage
async def main():
    user_query = "Randy has 9 oatmeal cookies, 4 chocolate chip cookies, and 5 sugar cookies. He ate 3 cookies for an early day snack, one of each flavor. He ate 2 oatmeal cookies for lunch. He gives 2 sugar cookies to his friends. Then, he bakes 4 of each flavor for dinner. How many cookies does he have now?"
    result = await handle_user_query(user_query)


if __name__ == "__main__":
    import asyncio

    asyncio.run(main())
